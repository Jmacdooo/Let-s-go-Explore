<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Forever Dog ‚Äî Parks</title>
  <style>
    :root{
      --panel: rgba(255,255,255,.92);
      --shadow: 0 10px 30px rgba(0,0,0,.18);
    }
    html,body{ margin:0; height:100%; overflow:hidden; font-family:system-ui,-apple-system,Segoe UI,Arial,sans-serif; background:#bde0fe; }
    canvas{ display:block; width:100vw; height:100vh; }

    #controls{
      position:fixed; left:12px; top:12px; z-index:10;
      background:var(--panel); box-shadow:var(--shadow);
      padding:10px 12px; border-radius:14px;
      display:flex; gap:8px; flex-wrap:wrap; align-items:center;
      user-select:none;
    }
    .btn{
      padding:9px 11px; border:none; border-radius:12px; cursor:pointer;
      font-weight:700; background:#ffb703;
    }
    .btn.alt{ background:#8ecae6; }
    .btn.danger{ background:#fb8500; }
    .tiny{
      font-size:12px; opacity:.7; font-weight:600;
      margin-left:6px;
    }

    #msg{
      position:fixed; left:50%; bottom:12px; transform:translateX(-50%);
      z-index:10;
      background:rgba(255,255,255,.92); box-shadow:var(--shadow);
      padding:10px 14px; border-radius:14px;
      max-width:min(740px, calc(100vw - 24px));
      text-align:center; font-weight:700;
    }
  </style>
</head>
<body>
  <div id="controls">
    <button class="btn alt" id="walkL">‚¨ÖÔ∏è Walk</button>
    <button class="btn alt" id="walkR">Walk ‚û°Ô∏è</button>
    <button class="btn danger" id="stop">‚èπ Stop</button>

    <button class="btn" id="pet">ü´∂ Pet</button>
    <button class="btn" id="feed">ü¶¥ Feed</button>
    <button class="btn alt" id="sleep">üò¥ Sleep</button>

    <span class="tiny">Tip: walk to the sign to ‚Äúarrive‚Äù at a landmark.</span>
  </div>

  <div id="msg">Loading‚Ä¶</div>
  <canvas id="c"></canvas>

<script>
(() => {
  // ========= YOU EDIT THESE =========
  // Main Yosemite background (already in your repo): assets/yosemite.png
  const DEFAULT_BG = "assets/yosemite.png";

  // Add THIS file for Half Dome (you asked for a second picture)
  // Put it in: assets/half_dome.png  (or rename here)
  const HALF_DOME_BG = "assets/half_dome.png";

  // Landmarks are along a 0..1 "trail" (t). When dog gets close, it "arrives".
  // Half Dome uses the special background.
  const LANDMARKS = [
    { name: "Tunnel View",  t: 0.18, bg: DEFAULT_BG },
    { name: "El Capitan",   t: 0.40, bg: DEFAULT_BG },
    { name: "Half Dome",    t: 0.62, bg: HALF_DOME_BG }, // <-- switches background here
    { name: "Yosemite Falls", t: 0.82, bg: DEFAULT_BG },
  ];

  // ========= ASSET PATHS (match your repo listing) =========
  const ASSETS = {
    idle:  "assets/dog_idle.png",
    walk:  "assets/dog_walk.png",
    paw:   "assets/dog_paw.png",
    eat:   "assets/dog_eat.png",
    sleep: "assets/dog_sleep.png",
    bark:  "assets/bark.mp3",
  };

  // IMPORTANT: your strips are 5 frames (this is what stopped the ‚Äúmultiple dogs‚Äù bug)
  const FRAMES = { idle:5, walk:5, paw:5, eat:5, sleep:5 };

  // ========= CANVAS SETUP =========
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const msgEl = document.getElementById("msg");

  function resize(){
    canvas.width = Math.floor(window.innerWidth * devicePixelRatio);
    canvas.height = Math.floor(window.innerHeight * devicePixelRatio);
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  window.addEventListener("resize", resize);
  resize();

  // ========= HELPERS =========
  function setMsg(t){ msgEl.textContent = t; }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

  function coverDraw(img){
    // Draw img to cover the whole screen without distortion
    const w = window.innerWidth, h = window.innerHeight;
    const iw = img.naturalWidth || img.width, ih = img.naturalHeight || img.height;
    if (!iw || !ih) return;
    const scale = Math.max(w/iw, h/ih);
    const dw = iw * scale, dh = ih * scale;
    const dx = (w - dw) / 2, dy = (h - dh) / 2;
    ctx.drawImage(img, dx, dy, dw, dh);
  }

  function drawSign(textTop, textBottom){
    const w = window.innerWidth, h = window.innerHeight;
    const signW = Math.min(520, w - 40);
    const signH = 130;
    const x = (w - signW)/2;
    const y = Math.max(70, h*0.18);

    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    roundRect(x, y, signW, signH, 18);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(0,0,0,0.12)";
    roundRect(x, y, signW, signH, 18);
    ctx.stroke();

    ctx.fillStyle = "rgba(0,0,0,0.85)";
    ctx.font = "800 22px system-ui,-apple-system,Segoe UI,Arial";
    ctx.textAlign = "center";
    ctx.fillText(textTop, x + signW/2, y + 52);
    ctx.font = "700 18px system-ui,-apple-system,Segoe UI,Arial";
    ctx.fillText(textBottom, x + signW/2, y + 88);
    ctx.restore();
  }

  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y, x+w,y+h, r);
    ctx.arcTo(x+w,y+h, x,y+h, r);
    ctx.arcTo(x,y+h, x,y, r);
    ctx.arcTo(x,y, x+w,y, r);
    ctx.closePath();
  }

  // ========= AUDIO + SPEECH (bark ONLY on pet/feed) =========
  const barkAudio = new Audio(ASSETS.bark);
  barkAudio.volume = 0.55;

  let voices = [];
  function loadVoices(){
    voices = speechSynthesis.getVoices() || [];
  }
  loadVoices();
  window.speechSynthesis.onvoiceschanged = loadVoices;

  function speak(text){
    try{
      speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);
      // pick a stable english voice if available
      const v = voices.find(v => /en/i.test(v.lang)) || voices[0];
      if (v) u.voice = v;
      u.rate = 1.0;
      u.pitch = 1.05;
      speechSynthesis.speak(u);
    }catch(e){}
  }

  // ========= IMAGE LOADER =========
  function loadImage(src){
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve({img, ok:true, src});
      img.onerror = () => resolve({img:null, ok:false, src});
      img.src = src;
    });
  }

  // ========= SPRITE =========
  class Sprite {
    constructor(img, frames, fps){
      this.img = img;
      this.frames = frames;
      this.fps = fps;
      this.t = 0;
      this.frame = 0;
    }
    update(dt){
      this.t += dt;
      const f = Math.floor(this.t * this.fps) % this.frames;
      this.frame = f;
    }
    draw(x, y, w, h, flip){
      if (!this.img) return;
      const iw = this.img.naturalWidth || this.img.width;
      const ih = this.img.naturalHeight || this.img.height;
      const fw = iw / this.frames;

      // safety: if image isn't divisible, just bail to avoid ‚Äúmultiple dogs‚Äù smear
      if (!isFinite(fw) || fw <= 1) return;

      ctx.save();
      ctx.translate(x, y);
      ctx.scale(flip ? -1 : 1, 1);
      ctx.drawImage(
        this.img,
        Math.floor(this.frame * fw), 0, Math.floor(fw), ih,
        -w/2, -h, w, h
      );
      ctx.restore();
    }
    reset(){
      this.t = 0;
      this.frame = 0;
    }
  }

  // ========= GAME STATE =========
  const state = {
    dogT: 0.05,        // 0..1 along the trail
    vx: 0,             // -1 left, +1 right
    facingRight: true,
    mode: "idle",      // idle | walk | paw | eat | sleep
    actionUntil: 0,    // timestamp when action ends
    arrivedIndex: -1,  // last landmark "arrived" (within range)
    bgImg: null,       // current background image object
    bgSrc: DEFAULT_BG,
  };

  const SPEED = 0.10;          // trail units / second
  const ARRIVE_RANGE = 0.025;  // how close to be "at" landmark

  // ========= UI HOOKS =========
  const walkLBtn = document.getElementById("walkL");
  const walkRBtn = document.getElementById("walkR");
  const stopBtn  = document.getElementById("stop");
  const petBtn   = document.getElementById("pet");
  const feedBtn  = document.getElementById("feed");
  const sleepBtn = document.getElementById("sleep");

  walkLBtn.onclick = () => { if (state.mode !== "sleep") { state.vx = -1; state.facingRight = false; } };
  walkRBtn.onclick = () => { if (state.mode !== "sleep") { state.vx =  1; state.facingRight = true;  } };
  stopBtn.onclick  = () => { state.vx = 0; };

  petBtn.onclick = () => {
    if (state.mode === "sleep") return;
    barkAudio.currentTime = 0; barkAudio.play().catch(()=>{});
    state.mode = "paw"; state.actionUntil = performance.now() + 750;
    sprites.paw.reset();
    setMsg("Awww. Good pup! ü´∂");
    speak("Who's a good dog?");
  };

  feedBtn.onclick = () => {
    if (state.mode === "sleep") return;
    barkAudio.currentTime = 0; barkAudio.play().catch(()=>{});
    state.mode = "eat"; state.actionUntil = performance.now() + 900;
    sprites.eat.reset();
    setMsg("Crunch crunch. ü¶¥");
    speak("Yum!");
  };

  sleepBtn.onclick = () => {
    if (state.mode === "sleep") {
      state.mode = "idle";
      setMsg("Up we go! ‚òÄÔ∏è");
      speak("I'm awake!");
    } else {
      state.vx = 0;
      state.mode = "sleep";
      sprites.sleep.reset();
      setMsg("Zzz‚Ä¶ üò¥");
      speak("Goodnight.");
    }
  };

  // ========= LOAD EVERYTHING =========
  let sprites = {};
  let bgCache = new Map(); // src -> Image

  async function boot(){
    setMsg("Loading dog + Yosemite‚Ä¶");

    const [idle, walk, paw, eat, sleep, bgDefault, bgHalf] = await Promise.all([
      loadImage(ASSETS.idle),
      loadImage(ASSETS.walk),
      loadImage(ASSETS.paw),
      loadImage(ASSETS.eat),
      loadImage(ASSETS.sleep),
      loadImage(DEFAULT_BG),
      loadImage(HALF_DOME_BG),
    ]);

    // Cache backgrounds (if Half Dome file missing, we just won't switch)
    if (bgDefault.ok) bgCache.set(DEFAULT_BG, bgDefault.img);
    if (bgHalf.ok) bgCache.set(HALF_DOME_BG, bgHalf.img);

    sprites = {
      idle:  new Sprite(idle.ok  ? idle.img  : null, FRAMES.idle,  6),
      walk:  new Sprite(walk.ok  ? walk.img  : null, FRAMES.walk,  10),
      paw:   new Sprite(paw.ok   ? paw.img   : null, FRAMES.paw,   10),
      eat:   new Sprite(eat.ok   ? eat.img   : null, FRAMES.eat,   10),
      sleep: new Sprite(sleep.ok ? sleep.img : null, FRAMES.sleep,  5),
    };

    // Initial background
    state.bgSrc = DEFAULT_BG;
    state.bgImg = bgCache.get(DEFAULT_BG) || null;

    setMsg("Walk around Yosemite! üêæ (Half Dome swaps the background when you reach it.)");
    requestAnimationFrame(loop);
  }

  // ========= LANDMARK LOGIC =========
  function getCurrentLandmarkIndex(){
    // "Arrived" means within ARRIVE_RANGE of a landmark.
    for (let i=0;i<LANDMARKS.length;i++){
      if (Math.abs(state.dogT - LANDMARKS[i].t) <= ARRIVE_RANGE) return i;
    }
    return -1;
  }

  function updateBackgroundForLandmark(idx){
    const targetSrc = (idx >= 0 ? LANDMARKS[idx].bg : DEFAULT_BG);

    // If Half Dome image isn't present, fall back safely to DEFAULT_BG
    const img = bgCache.get(targetSrc) || bgCache.get(DEFAULT_BG) || null;

    state.bgSrc = targetSrc;
    state.bgImg = img;
  }

  // ========= DRAW =========
  function draw(){
    const w = window.innerWidth, h = window.innerHeight;

    // Background
    ctx.clearRect(0,0,w,h);
    if (state.bgImg){
      coverDraw(state.bgImg);
    } else {
      // fallback
      ctx.fillStyle = "#bde0fe";
      ctx.fillRect(0,0,w,h);
    }

    // Ground
    const groundY = Math.floor(h * 0.86);
    ctx.save();
    ctx.strokeStyle = "rgba(0,0,0,0.15)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(0, groundY);
    ctx.lineTo(w, groundY);
    ctx.stroke();
    ctx.restore();

    // Dog position from trail progress
    const x = w * (0.08 + state.dogT * 0.84);
    const dogW = Math.min(260, w * 0.18);
    const dogH = dogW; // square-ish

    // Choose sprite
    let spr = sprites.idle;
    if (state.mode === "walk") spr = sprites.walk;
    if (state.mode === "paw")  spr = sprites.paw;
    if (state.mode === "eat")  spr = sprites.eat;
    if (state.mode === "sleep")spr = sprites.sleep;

    // Draw dog
    spr.draw(x, groundY, dogW, dogH, !state.facingRight);

    // Landmark sign if close
    const idx = getCurrentLandmarkIndex();
    if (idx >= 0){
      const top = LANDMARKS[idx].name;
      const bottom = `Landmark ${idx + 1} of ${LANDMARKS.length}`;
      drawSign(top, bottom);
    }
  }

  // ========= UPDATE LOOP =========
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;

    // action timeout -> return to idle/walk
    if ((state.mode === "paw" || state.mode ==
