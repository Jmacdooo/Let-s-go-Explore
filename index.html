<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Calm Dog v7 — Opening Script + Breathing</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Arial,sans-serif;background:#eaf4ff;}
    canvas{display:block;width:100vw;height:100vh;}

    #banner{
      position:fixed;left:50%;top:10px;transform:translateX(-50%);
      z-index:20;font-weight:1000;letter-spacing:.4px;
      background:rgba(0,0,0,.70);color:#fff;padding:8px 12px;border-radius:999px;
      box-shadow:0 10px 30px rgba(0,0,0,.20);
    }

    #hud{
      position:fixed;left:12px;top:12px;z-index:21;
      background:rgba(255,255,255,.92);box-shadow:0 10px 30px rgba(0,0,0,.18);
      padding:10px 12px;border-radius:16px;user-select:none;
      display:flex;gap:8px;align-items:center;flex-wrap:wrap;
    }
    .btn{border:none;border-radius:14px;padding:10px 12px;font-weight:900;cursor:pointer;background:#ffd166;}
    .btn.secondary{background:#e9ecef;}

    #hint{
      position:fixed;left:50%;bottom:14px;transform:translateX(-50%);
      background:rgba(255,255,255,.92);box-shadow:0 10px 30px rgba(0,0,0,.18);
      padding:10px 14px;border-radius:16px;
      font-weight:900;text-align:center;max-width:min(920px, calc(100vw - 24px));
      z-index:21;line-height:1.25;
    }
    #hint small{display:block;font-weight:800;opacity:.75;margin-top:4px;}

    #errorBanner{
      position:fixed;left:12px;right:12px;top:78px;z-index:9999;
      background:rgba(180,0,0,.92);color:#fff;
      padding:12px 14px;border-radius:14px;
      font-weight:800;display:none;white-space:pre-wrap;
      box-shadow:0 10px 30px rgba(0,0,0,.25);
    }
  </style>
</head>
<body>

  <div id="banner">CALM DOG v7 ✅</div>

  <div id="hud">
    <button class="btn" id="startBtn">Start</button>
    <button class="btn secondary" id="restartBtn">Restart</button>
    <button class="btn secondary" id="voiceBtn">Voice: ON</button>
  </div>

  <div id="hint">
    Ready to be calm and go for a walk?
    <small>Tap Start (or tap anywhere) to begin.</small>
  </div>

  <div id="errorBanner"></div>
  <canvas id="c"></canvas>

<script>
(() => {
  const errorBanner = document.getElementById("errorBanner");
  const showError = (msg) => {
    errorBanner.style.display = "block";
    errorBanner.textContent = String(msg);
  };
  window.addEventListener("error", (e)=>showError("JS Error:\n" + (e.error?.stack || e.message || e)));
  window.addEventListener("unhandledrejection", (e)=>showError("Promise Error:\n" + (e.reason?.stack || e.reason || e)));

  // ---------- CALM SETTINGS ----------
  const PHASE_MS = 4200;                 // slower inhale/exhale (try 3600–5000)
  const SCALE_MIN = 0.62;
  const SCALE_MAX = 2.10;

  // Drop dog lower during breathing so it won't cover numbers:
  const BREATH_DOG_DROP_BASE = 70;
  const BREATH_DOG_DROP_PER_SCALE = 55;
  const BREATH_DOG_DROP_MAX = 170;
  // -------------------------------

  // ---------- OPTIONAL ASSETS ----------
  // Put files here:
  // ./assets/yosemite.png
  // ./assets/dog_idle.png
  // ./assets/dog_walk.png
  const ASSETS = {
    bg:   "./assets/yosemite.png",
    idle: "./assets/dog_idle.png",
    walk: "./assets/dog_walk.png"
  };
  const WALK_FRAMES = 5; // change to 6 if your strip has 6 frames
  // ------------------------------------

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const hint = document.getElementById("hint");
  const startBtn = document.getElementById("startBtn");
  const restartBtn = document.getElementById("restartBtn");
  const voiceBtn = document.getElementById("voiceBtn");

  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width  = Math.floor(window.innerWidth  * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resize);
  resize();

  // ---------- Safe image load ----------
  const loadImage = (src) => new Promise((resolve)=>{
    const img = new Image();
    img.onload = ()=>resolve(img);
    img.onerror = ()=>resolve(null);
    img.src = src;
  });

  let bgImg=null, idleImg=null, walkImg=null;
  (async ()=>{
    [bgImg, idleImg, walkImg] = await Promise.all([
      loadImage(ASSETS.bg),
      loadImage(ASSETS.idle),
      loadImage(ASSETS.walk),
    ]);
  })();

  // ---------- Voice (child-like, sequential safe) ----------
  const hasSpeech = ("speechSynthesis" in window) && ("SpeechSynthesisUtterance" in window);
  const VOICE = { on:true, voice:null, rate:0.88, pitch:2.25 };

  function pickVoice(){
    if (!hasSpeech) return;
    const vs = speechSynthesis.getVoices?.() || [];
    const en = vs.filter(v => /en/i.test(v.lang));
    VOICE.voice =
      en.find(v => /(Google US English|Samantha|Ava|Aria|Jenny|Allison|Zira)/i.test(v.name)) ||
      en.find(v => /Google/i.test(v.name)) ||
      en[0] || vs[0] || null;
  }
  if (hasSpeech){
    speechSynthesis.onvoiceschanged = pickVoice;
    pickVoice();
  }

  function cancelSpeech(){
    if (!hasSpeech) return;
    try{ speechSynthesis.cancel(); }catch(e){}
  }

  // Speak ONE line and resolve when done (no overlap, baby-proof)
  function sayAsync(text, { interrupt=false } = {}){
    return new Promise((resolve)=>{
      if (!VOICE.on || !hasSpeech){
        resolve();
        return;
      }
      if (interrupt) cancelSpeech();

      const u = new SpeechSynthesisUtterance(String(text));
      if (VOICE.voice) u.voice = VOICE.voice;
      u.rate = VOICE.rate;
      u.pitch = VOICE.pitch;
      u.volume = 1.0;

      let done = false;
      const finish = () => {
        if (done) return;
        done = true;
        resolve();
      };

      u.onend = finish;
      u.onerror = finish;

      try{
        speechSynthesis.speak(u);
      }catch(e){
        finish();
      }

      // watchdog so we never hang
      setTimeout(finish, 8000);
    });
  }

  voiceBtn.addEventListener("click", ()=>{
    VOICE.on = !VOICE.on;
    voiceBtn.textContent = VOICE.on ? "Voice: ON" : "Voice: OFF";
    if (!VOICE.on) cancelSpeech();
  });

  // ---------- Baby-proof input (hold left/right half of screen) ----------
  let left=false, right=false;
  window.addEventListener("keydown", (e)=>{ if(e.key==="ArrowLeft")left=true; if(e.key==="ArrowRight")right=true; });
  window.addEventListener("keyup", (e)=>{ if(e.key==="ArrowLeft")left=false; if(e.key==="ArrowRight")right=false; });

  function handlePointer(e, isDown){
    const x = e.clientX;
    if (!isDown){ left=false; right=false; return; }
    if (x < window.innerWidth/2){ left=true; right=false; }
    else { right=true; left=false; }
  }
  window.addEventListener("pointerdown", (e)=>handlePointer(e,true));
  window.addEventListener("pointermove", (e)=>{ if(e.buttons) handlePointer(e,true); });
  window.addEventListener("pointerup",   (e)=>handlePointer(e,false));
  window.addEventListener("pointercancel",(e)=>handlePointer(e,false));

  // ---------- Landmarks ----------
  const parks = [
    { name:"Landmark 1", pos:0.18, visited:false },
    { name:"Landmark 2", pos:0.36, visited:false },
    { name:"Landmark 3", pos:0.54, visited:false },
    { name:"Landmark 4", pos:0.72, visited:false },
    { name:"Landmark 5", pos:0.88, visited:false },
  ];

  // ---------- State ----------
  const MODE = { INTRO:"intro", OPENING:"opening", BREATH:"breath", WALK:"walk", STOP:"stop" };
  let mode = MODE.INTRO;

  const dog = { x: window.innerWidth*0.5, speed:240, frame:0, animMs:0, warmupFrames:0 };

  const TOTAL_CYCLES = 3;
  let cycle = 1;
  let phase = "in";          // "in" | "out"
  let phaseStart = 0;

  const easeInOut = (t)=> t<0.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;
  const lerp = (a,b,t)=> a + (b-a)*t;

  async function speakPhase(phaseName){
    // Cancel any previous phrase so we never overlap
    const line = (phaseName === "in")
      ? "Breathe in… one… two… three…"
      : "Breathe out… one… two… three…";
    await sayAsync(line, { interrupt:true });
  }

  function reset(){
    cancelSpeech();
    mode = MODE.INTRO;
    cycle = 1; phase="in"; phaseStart=0;
    dog.x = window.innerWidth*0.5;
    dog.frame=0; dog.animMs=0; dog.warmupFrames=0;
    parks.forEach(p=>p.visited=false);
    hint.innerHTML = `Ready to be calm and go for a walk?<small>Tap Start (or tap anywhere) to begin.</small>`;
  }

  let starting = false;
  async function startFlow(){
    if (starting) return;
    if (mode !== MODE.INTRO) return;

    starting = true;
    mode = MODE.OPENING;
    dog.x = window.innerWidth*0.5;

    hint.innerHTML = `Getting ready…<small>Listen to the calm dog.</small>`;

    // Opening script (sequential, no overlap)
    await sayAsync("Hi!", { interrupt:true });
    await sayAsync("Let’s get ready for a walk.", {});
    await sayAsync("First we calm our bodies and our minds before we begin.", {});
    await sayAsync("Let’s breathe together.", {});
    await sayAsync("Ready?", {});

    // Now start breathing animation + first count
    mode = MODE.BREATH;
    cycle = 1;
    phase = "in";
    phaseStart = performance.now();

    hint.innerHTML = `Let’s do <b>3 breaths</b>.<small>In 1-2-3… Out 1-2-3…</small>`;

    // speak the first phase line
    speakPhase("in");

    starting = false;
  }

  function startWalking(){
    mode = MODE.WALK;
    dog.warmupFrames = 5;
    dog.frame = 0; dog.animMs = 0;

    // friendly transition
    sayAsync("Great job!", { interrupt:true });
    sayAsync("Now let’s walk.", {});

    hint.innerHTML = `Walking…<small>Hold left/right side of the screen to move.</small>`;
  }

  function stopAt(name){
    mode = MODE.STOP;
    left=false; right=false;
    sayAsync("We made it!", { interrupt:true });
    sayAsync(name + "!", {});
    hint.innerHTML = `We reached <b>${name}</b>!<small>Tap anywhere to keep walking.</small>`;
  }

  // UI
  startBtn.addEventListener("click", startFlow);
  restartBtn.addEventListener("click", reset);

  window.addEventListener("click", ()=>{
    if (mode === MODE.INTRO) startFlow();
    else if (mode === MODE.STOP){
      mode = MODE.WALK;
      dog.warmupFrames = 5;
      dog.frame = 0; dog.animMs = 0;
      hint.innerHTML = `Walking…<small>Hold left/right side of the screen to move.</small>`;
    }
  });

  // ---------- Drawing helpers ----------
  function coverDraw(img, w, h){
    const iw = img.width, ih = img.height;
    const sc = Math.max(w/iw, h/ih);
    const dw = iw*sc, dh = ih*sc;
    ctx.drawImage(img, (w-dw)/2, (h-dh)/2, dw, dh);
  }

  function isStrip(img){ return img && (img.width / img.height) >= 2.0; }
  function frameW(img){ return !img ? 0 : (isStrip(img) ? img.width / WALK_FRAMES : img.width); }
  function frameAspect(img){
    if (!img) return 0.90;
    const fw = frameW(img) || 1;
    return img.height / fw;
  }

  function drawCartoonDog(cx, cy, dw, dh){
    ctx.save();
    ctx.translate(cx, cy);
    ctx.fillStyle = "rgba(35,45,70,.92)";
    ctx.beginPath(); ctx.ellipse(0, 0, dw*0.28, dh*0.20, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(dw*0.16, -dh*0.06, dw*0.16, dh*0.14, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "rgba(25,35,55,.92)";
    ctx.beginPath(); ctx.ellipse(dw*0.24, -dh*0.16, dw*0.09, dh*0.08, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "rgba(255,255,255,.95)";
    ctx.beginPath(); ctx.arc(dw*0.20, -dh*0.07, Math.max(3,dw*0.02), 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "rgba(0,0,0,.85)";
    ctx.beginPath(); ctx.arc(dw*0.205, -dh*0.07, Math.max(2,dw*0.01), 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,.80)";
    ctx.lineWidth = Math.max(2, dw*0.01);
    ctx.beginPath(); ctx.arc(dw*0.205, -dh*0.03, dw*0.05, 0.15*Math.PI, 0.85*Math.PI); ctx.stroke();
    ctx.restore();
  }

  function drawDog(img, cx, groundY, baseW, scale, frameIndex, flipX, yOffset){
    const a = frameAspect(img);
    const dw = baseW * scale;
    const dh = dw * a;

    const feetLift = dh * 0.10;
    const cy = groundY - (dh/2) + feetLift + (yOffset || 0);

    if (!img){
      drawCartoonDog(cx, cy, dw, dh);
      return;
    }

    const frames = isStrip(img) ? WALK_FRAMES : 1;
    const fw = frameW(img);
    const fh = img.height;
    const f = frames > 1 ? (frameIndex % frames) : 0;

    ctx.save();
    ctx.translate(cx, cy);
    if (flipX) ctx.scale(-1,1);
    ctx.drawImage(img, f*fw, 0, fw, fh, -dw/2, -dh/2, dw, dh);
    ctx.restore();
  }

  function drawBackground(w,h){
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, "#eaf4ff");
    g.addColorStop(1, "#f7fbff");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    if (bgImg){
      coverDraw(bgImg, w, h);
      ctx.fillStyle = "rgba(255,255,255,.10)";
      ctx.fillRect(0,0,w,h);
    }

    const groundY = Math.round(h*0.78);
    ctx.fillStyle = "rgba(40,90,70,.18)";
    ctx.fillRect(0, groundY, w, h-groundY);
    return groundY;
  }

  function drawParks(w, groundY){
    ctx.textAlign = "center";
    parks.forEach(p=>{
      const px = p.pos*w;
      ctx.fillStyle = p.visited ? "rgba(0,140,90,.80)" : "rgba(0,0,0,.22)";
      ctx.beginPath(); ctx.arc(px, groundY-10, 7, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = "rgba(0,0,0,.70)";
      ctx.font = "800 12px system-ui, -apple-system, Segoe UI, Arial";
      ctx.fillText(p.name, px, groundY+18);
      if (p.visited){
        ctx.font="900 14px system-ui, -apple-system, Segoe UI, Arial";
        ctx.fillText("✓", px, groundY+34);
      }
    });
  }

  // ---------- Updates ----------
  function updateBreath(now){
    const elapsed = now - phaseStart;
    const t = Math.min(1, elapsed / PHASE_MS);
    const e = easeInOut(t);

    const scale = (phase==="in") ? lerp(SCALE_MIN, SCALE_MAX, e) : lerp(SCALE_MAX, SCALE_MIN, e);

    // beat shown evenly across PHASE_MS
    const beatLen = PHASE_MS / 3;
    const beat = Math.min(3, Math.floor(elapsed / beatLen) + 1);

    if (t >= 1){
      if (phase === "in"){
        phase = "out";
        phaseStart = now;
        speakPhase("out");
      } else {
        if (cycle >= TOTAL_CYCLES){
          startWalking();
        } else {
          cycle += 1;
          phase = "in";
          phaseStart = now;
          speakPhase("in");
        }
      }
    }
    return { scale, beat };
  }

  function updateWalk(dt, w){
    dog.animMs += dt*1000;
    if (dog.animMs >= 120){
      dog.animMs = 0;
      dog.frame = (dog.frame + 1) % WALK_FRAMES;
      if (dog.warmupFrames > 0) dog.warmupFrames--;
    }
    const canMove = (dog.warmupFrames === 0);

    if (canMove){
      if (left)  dog.x -= dog.speed * dt;
      if (right) dog.x += dog.speed * dt;
    }

    dog.x = Math.max(60, Math.min(w - 60, dog.x));

    const center = dog.x;
    parks.forEach(p=>{
      const px = p.pos*w;
      if (!p.visited && Math.abs(center - px) < 45 && canMove){
        p.visited = true;
        stopAt(p.name);
      }
    });
  }

  // ---------- Main loop ----------
  let last = performance.now();
  function loop(now){
    const w = window.innerWidth;
    const h = window.innerHeight;
    const dt = Math.min(0.05, (now-last)/1000);
    last = now;

    const groundY = drawBackground(w,h);
    drawParks(w, groundY);

    const baseW = Math.min(360, Math.max(180, w*0.30));

    let scale = 1.08;
    let beat = 1;

    if (mode === MODE.INTRO || mode === MODE.OPENING || mode === MODE.BREATH){
      dog.x = w*0.5;
    }

    if (mode === MODE.BREATH){
      const b = updateBreath(now);
      scale = b.scale;
      beat = b.beat;

      ctx.fillStyle = "rgba(0,0,0,.75)";
      ctx.textAlign = "center";
      ctx.font = "900 22px system-ui, -apple-system, Segoe UI, Arial";
      ctx.fillText(`Breath ${cycle} of 3`, w*0.5, 92);

      ctx.font = "900 34px system-ui, -apple-system, Segoe UI, Arial";
      ctx.fillText(phase === "in" ? "IN…" : "OUT…", w*0.5, 136);

      ctx.font = "1000 70px system-ui, -apple-system, Segoe UI, Arial";
      ctx.fillText(String(beat), w*0.5, 212);
    }

    if (mode === MODE.WALK){
      updateWalk(dt, w);
    }

    if (mode === MODE.STOP){
      scale = 1.06 + Math.sin(now/700)*0.02;
    }

    const img = (mode === MODE.WALK ? walkImg : idleImg) || null;
    const frameIndex = (mode === MODE.WALK ? dog.frame : 0);
    const flipX = left ? true : (right ? false : false);

    // Lower dog during breathing so it never covers the numbers
    let yOffset = 0;
    if (mode === MODE.BREATH){
      const extra = Math.max(0, (scale - 1)) * BREATH_DOG_DROP_PER_SCALE;
      yOffset = Math.min(BREATH_DOG_DROP_MAX, BREATH_DOG_DROP_BASE + extra);
    }

    const drawX = (mode === MODE.WALK || mode === MODE.STOP) ? dog.x : (w*0.5);
    drawDog(img, drawX, groundY, baseW, scale, frameIndex, flipX, yOffset);

    // Status line
    ctx.fillStyle = "rgba(0,0,0,.70)";
    ctx.textAlign = "left";
    ctx.font = "800 12px system-ui, -apple-system, Segoe UI, Arial";
    ctx.fillText(
      `MODE:${mode}  BG:${bgImg?"ok":"missing"}  IDLE:${idleImg?"ok":"missing"}  WALK:${walkImg?"ok":"missing"}  Voice:${VOICE.on?"on":"off"}`,
      14, h-14
    );

    requestAnimationFrame(loop);
  }

  reset();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
