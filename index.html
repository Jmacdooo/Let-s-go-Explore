<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>My Forever Dog ‚Äî Road Trip (Fixed Dog Walk)</title>
<style>
  :root { --panel: rgba(255,255,255,.92); --shadow: 0 10px 30px rgba(0,0,0,.18); }
  html,body{margin:0;height:100%;background:#dff2ff;font-family:system-ui,-apple-system,Segoe UI,Arial,sans-serif;overflow:hidden;}
  canvas{display:block;width:100vw;height:100vh;}
  #topbar{
    position:fixed; left:12px; top:12px; z-index:5;
    display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    background:var(--panel); box-shadow:var(--shadow);
    padding:10px 12px; border-radius:14px;
  }
  #topbar b{font-size:14px}
  #topbar .pill{font-size:12px;background:#fff;border:1px solid rgba(0,0,0,.10);border-radius:999px;padding:6px 10px}
  #hint{
    position:fixed; left:12px; bottom:12px; z-index:5;
    background:var(--panel); box-shadow:var(--shadow);
    padding:10px 12px; border-radius:14px; font-size:12px; max-width:420px;
  }
  input[type="file"]{font-size:12px}
  button{
    cursor:pointer; border:none; border-radius:10px; padding:8px 10px;
    background:#111; color:#fff; font-weight:600; font-size:12px;
  }
  button.secondary{background:#fff;color:#111;border:1px solid rgba(0,0,0,.12)}
</style>
</head>
<body>

<div id="topbar">
  <b>üêæ Dog Walk Fix</b>
  <span class="pill">Arrows / WASD to move</span>
  <span class="pill">Shift = run</span>
  <label class="pill" title="Use your sprite sheet PNG">
    Load dog sprite:
    <input id="file" type="file" accept="image/png,image/webp,image/jpeg">
  </label>
  <button id="reset" class="secondary">Reset</button>
</div>

<div id="hint">
  If your dog image has a <b>black background</b>, this code automatically removes ‚Äúnear-black‚Äù pixels so it becomes transparent.
  <br><br>
  Put your sprite sheet file next to this HTML and name it <b>dog_walk.png</b> OR use the ‚ÄúLoad dog sprite‚Äù button.
</div>

<canvas id="game"></canvas>

<script>
/* =========================
   CANVAS + RESIZE
========================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", { alpha:true });

function resize(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  canvas.width  = Math.floor(innerWidth  * dpr);
  canvas.height = Math.floor(innerHeight * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener("resize", resize);
resize();

/* =========================
   WORLD + CAMERA
========================= */
const WORLD_W = 2600;
const WORLD_H = 1500;

const camera = { x:0, y:0 };
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

/* =========================
   INPUT
========================= */
const keys = new Set();
addEventListener("keydown",(e)=>keys.add(e.key.toLowerCase()));
addEventListener("keyup",(e)=>keys.delete(e.key.toLowerCase()));

/* =========================
   DOG SPRITE LOADING
   - supports sprite sheet (frames in one row)
   - removes near-black background to make transparent
========================= */
const dogImg = new Image();
dogImg.crossOrigin = "anonymous";

let dogSheetCanvas = null;   // processed (transparent) sheet
let dogSheetCtx = null;

let FRAME_COUNT = 6;         // <<< change if your sheet has different frame count
let frameW = 0, frameH = 0;

function setFrames(n){
  FRAME_COUNT = Math.max(1, n|0);
  if(dogSheetCanvas){
    frameW = Math.floor(dogSheetCanvas.width / FRAME_COUNT);
    frameH = dogSheetCanvas.height;
  }
}

function makeNearBlackTransparent(img){
  // Draw to offscreen and convert near-black pixels to transparent
  const off = document.createElement("canvas");
  off.width = img.naturalWidth || img.width;
  off.height = img.naturalHeight || img.height;
  const octx = off.getContext("2d", { willReadFrequently:true });
  octx.clearRect(0,0,off.width,off.height);
  octx.drawImage(img,0,0);

  const imageData = octx.getImageData(0,0,off.width,off.height);
  const d = imageData.data;

  // Threshold: anything close to black becomes transparent.
  // This fixes your sheet that‚Äôs ‚Äútransparent-looking‚Äù but actually black.
  const TH = 18; // raise to remove more; lower to keep darker fur details
  for(let i=0;i<d.length;i+=4){
    const r=d[i], g=d[i+1], b=d[i+2], a=d[i+3];
    if(a === 0) continue;
    if(r < TH && g < TH && b < TH){
      d[i+3] = 0;
    }
  }
  octx.putImageData(imageData,0,0);
  return off;
}

function loadDogFromImage(img){
  dogSheetCanvas = makeNearBlackTransparent(img);
  dogSheetCtx = dogSheetCanvas.getContext("2d");
  setFrames(FRAME_COUNT);

  // If the sheet is tall and has a lot of empty space, auto-crop vertically
  // (keeps the dog from being tiny / floating in a giant sheet).
  autoCropSheet();
}

function autoCropSheet(){
  if(!dogSheetCanvas) return;

  // Scan alpha bounds to crop to dog row
  const w = dogSheetCanvas.width, h = dogSheetCanvas.height;
  const data = dogSheetCtx.getImageData(0,0,w,h).data;

  let top=h, bottom=0;
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const a = data[(y*w + x)*4 + 3];
      if(a > 0){
        if(y < top) top = y;
        if(y > bottom) bottom = y;
      }
    }
  }
  if(top >= bottom) return; // nothing found

  // Add padding
  top = Math.max(0, top - 8);
  bottom = Math.min(h-1, bottom + 8);

  const newH = (bottom - top + 1);
  const cropped = document.createElement("canvas");
  cropped.width = w;
  cropped.height = newH;
  const cctx = cropped.getContext("2d");
  cctx.drawImage(dogSheetCanvas, 0, top, w, newH, 0, 0, w, newH);

  dogSheetCanvas = cropped;
  dogSheetCtx = dogSheetCanvas.getContext("2d");
  setFrames(FRAME_COUNT);
}

/* Try to load default filename if present */
dogImg.onload = () => loadDogFromImage(dogImg);
dogImg.onerror = () => {
  // No crash if file not found. You can load via the file picker.
  console.warn("Could not auto-load dog_walk.png. Use the file picker.");
};
dogImg.src = "dog_walk.png";

/* File picker */
document.getElementById("file").addEventListener("change",(e)=>{
  const f = e.target.files?.[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  const tmp = new Image();
  tmp.onload = () => { loadDogFromImage(tmp); URL.revokeObjectURL(url); };
  tmp.src = url;
});

/* =========================
   DOG ENTITY
========================= */
const dog = {
  x: WORLD_W/2,
  y: WORLD_H/2,
  vx: 0,
  vy: 0,
  facing: 1,          // 1 = right, -1 = left
  animT: 0,
  frame: 0,
  speed: 260,         // px/s
  runMult: 1.8
};

/* =========================
   FOREGROUND ‚ÄúSIGNS‚Äù
   (these draw AFTER the dog so the dog appears BELOW them)
========================= */
const signs = [
  {x: 520,  y: 420,  w: 140, h: 120, label: "Park"},
  {x: 1250, y: 700,  w: 170, h: 140, label: "Trail"},
  {x: 1980, y: 520,  w: 160, h: 130, label: "Lake"}
];

/* =========================
   UPDATE
========================= */
let last = performance.now();

function update(dt){
  const left  = keys.has("arrowleft") || keys.has("a");
  const right = keys.has("arrowright")|| keys.has("d");
  const up    = keys.has("arrowup")   || keys.has("w");
  const down  = keys.has("arrowdown") || keys.has("s");
  const run   = keys.has("shift");

  let ax = 0, ay = 0;
  if(left) ax -= 1;
  if(right) ax += 1;
  if(up) ay -= 1;
  if(down) ay += 1;

  // normalize for diagonal
  const mag = Math.hypot(ax,ay) || 1;
  ax /= mag; ay /= mag;

  const targetSpeed = dog.speed * (run ? dog.runMult : 1);

  dog.vx = ax * targetSpeed;
  dog.vy = ay * targetSpeed;

  dog.x += dog.vx * dt;
  dog.y += dog.vy * dt;

  dog.x = clamp(dog.x, 40, WORLD_W-40);
  dog.y = clamp(dog.y, 40, WORLD_H-40);

  // facing direction
  if(dog.vx > 5) dog.facing = 1;
  if(dog.vx < -5) dog.facing = -1;

  // animation
  const moving = (Math.abs(dog.vx) + Math.abs(dog.vy)) > 1;
  if(moving && dogSheetCanvas){
    dog.animT += dt;
    const fps = run ? 14 : 10;          // walk/run animation speed
    if(dog.animT >= 1/fps){
      dog.animT = 0;
      dog.frame = (dog.frame + 1) % FRAME_COUNT;
    }
  }else{
    dog.frame = 0; // idle = first frame
  }

  // camera follows dog
  camera.x = clamp(dog.x - innerWidth/2, 0, WORLD_W - innerWidth);
  camera.y = clamp(dog.y - innerHeight/2, 0, WORLD_H - innerHeight);
}

/* =========================
   DRAW
========================= */
function draw(){
  // sky background
  ctx.clearRect(0,0,innerWidth,innerHeight);

  // ‚Äúworld‚Äù ground gradient
  ctx.save();
  ctx.fillStyle = "#dff2ff";
  ctx.fillRect(0,0,innerWidth,innerHeight);

  // draw distant ground
  ctx.translate(-camera.x, -camera.y);

  // ground
  ctx.fillStyle = "rgba(20,120,80,.18)";
  ctx.fillRect(0, 0, WORLD_W, WORLD_H);

  // simple ‚Äúpaths‚Äù
  ctx.fillStyle = "rgba(255,255,255,.35)";
  ctx.fillRect(120, 520, WORLD_W-240, 90);
  ctx.fillRect(900, 120, 90, WORLD_H-240);

  // background trees (cheap, but pretty)
  for(let i=0;i<70;i++){
    const x = (i*180) % WORLD_W;
    const y = 200 + ((i*97) % 900);
    ctx.fillStyle = "rgba(0,0,0,.12)";
    ctx.beginPath(); ctx.arc(x+40, y+30, 26, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "rgba(0,0,0,.10)";
    ctx.fillRect(x+36, y+52, 8, 30);
  }

  // --- DOG (draw BEFORE signs so signs cover him = ‚Äúbelow signs‚Äù) ---
  drawDog();

  // --- FOREGROUND SIGNS (on top of dog) ---
  for(const s of signs){
    // post
    ctx.fillStyle = "rgba(0,0,0,.18)";
    ctx.fillRect(s.x + s.w/2 - 8, s.y + s.h, 16, 60);

    // sign board
    ctx.fillStyle = "rgba(255,255,255,.92)";
    roundRect(ctx, s.x, s.y, s.w, s.h, 16, true, false);
    ctx.strokeStyle = "rgba(0,0,0,.18)";
    ctx.lineWidth = 2;
    roundRect(ctx, s.x, s.y, s.w, s.h, 16, false, true);

    ctx.fillStyle = "rgba(0,0,0,.75)";
    ctx.font = "bold 18px system-ui";
    ctx.fillText(s.label, s.x + 14, s.y + 34);
  }

  ctx.restore();

  // tiny HUD
  ctx.fillStyle = "rgba(0,0,0,.55)";
  ctx.font = "12px system-ui";
  ctx.fillText(`Dog: (${dog.x|0}, ${dog.y|0})  Frame: ${dog.frame+1}/${FRAME_COUNT}`, 14, innerHeight-14);
}

function drawDog(){
  const px = dog.x;
  const py = dog.y;

  // If sprite not loaded, draw placeholder
  if(!dogSheetCanvas || frameW <= 0){
    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.beginPath(); ctx.arc(px,py,26,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = "#fff";
    ctx.fillText("loading dog...", px-42, py-36);
    return;
  }

  // Choose size (BIG, not smooshed)
  // Maintain aspect ratio from the frame.
  const targetH = 150; // <<< make dog bigger/smaller here
  const scale = targetH / frameH;
  const drawW = frameW * scale;
  const drawH = frameH * scale;

  // Anchor dog to his feet (bottom center)
  const dx = px - drawW/2;
  const dy = py - drawH + 18; // small lift so paws sit on ground

  const sx = dog.frame * frameW;
  const sy = 0;

  // Draw ONLY ONE FRAME (this fixes ‚Äústrip moving backwards‚Äù)
  ctx.save();

  if(dog.facing === -1){
    // flip around the dog center so tail/nose direction is correct
    ctx.translate(px, 0);
    ctx.scale(-1, 1);
    ctx.translate(-px, 0);
  }

  ctx.imageSmoothingEnabled = true;
  ctx.drawImage(
    dogSheetCanvas,
    sx, sy, frameW, frameH,
    dx, dy, drawW, drawH
  );

  ctx.restore();
}

function roundRect(ctx, x, y, w, h, r, fill, stroke){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

/* =========================
   LOOP
========================= */
function loop(now){
  const dt = Math.min(0.033, (now - last) / 1000);
  last = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* =========================
   RESET BUTTON
========================= */
document.getElementById("reset").addEventListener("click", ()=>{
  dog.x = WORLD_W/2; dog.y = WORLD_H/2;
  dog.vx = dog.vy = 0;
  dog.facing = 1;
  dog.frame = 0;
});

/* =========================
   QUICK FIX KNOBS
   If your sheet has 7 frames instead of 6, change it HERE:
   setFrames(7);
========================= */
// setFrames(7);

</script>
</body>
</html>

